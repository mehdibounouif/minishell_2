typedef struct s_redirection {
    char *redirect;             // the symbol, like "<<"
    int redirection_type;       // enum value (HEREDOC, INFILE, OUTFILE, etc.)
    char *file;                 // for heredoc, this is the generated temp file
    struct s_tree *prev;        // the command associated with the redirection
} t_redirection;

test 3
append in >>

note "replace calloc in malloc"

test 4
minishell>echo hhhhhhh > out | chmod 000 out | > out
munmap_chunk(): invalid pointer
munmap_chunk(): invalid pointer

test 5
minishell>export a="s -l"
minishell>l$a
minishell : ls -l: command not found
minishell>
exit
[3]    356289 segmentation fault (core dumped)  ./minishell

if ((*list)->type == HEREDOC) // HEREDOC is the `<<` token
{
    char *heredoc_filename;
    bool quoted = is_quoted((*list)->next->content); // you can define this

    if (create_heredoc_file((*list)->next->content, quoted, &heredoc_filename) == -1)
    {
        // handle error
    }
    redirect_node->redirect->file = heredoc_filename;
}
else
{
    redirect_node->redirect->file = (*list)->content;
}

# in execution 

if (redirect->redirection_type == HEREDOC)
{
    int fd = open(redirect->file, O_RDONLY);
    dup2(fd, STDIN_FILENO);
}


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <readline/readline.h>

#define HEREDOC_TMP_FILE ".heredoc_tmp_" // will append a number

int create_heredoc_file(const char *delimiter, bool quoted, char **filename_out)
{
    static int  heredoc_count = 0;
    char        tmp_filename[64];
    char        *line;
    int         fd;

    // 1. Generate unique temp file name
    snprintf(tmp_filename, sizeof(tmp_filename), "%s%d", HEREDOC_TMP_FILE, heredoc_count++);
    
    fd = open(tmp_filename, O_CREAT | O_WRONLY | O_TRUNC, 0644);
    if (fd == -1)
        return (-1);

    while (1)
    {
        line = readline("heredoc> ");
        if (!line) // Ctrl-D
            break;

        if ((!quoted && strcmp(line, delimiter) == 0) || (quoted && strcmp(line, delimiter) == 0))
        {
            free(line);
            break;
        }

        // TODO: expand variables here if !quoted

        write(fd, line, strlen(line));
        write(fd, "\n", 1);
        free(line);
    }

    close(fd);

    *filename_out = strdup(tmp_filename); // store filename for AST/execution
    return (0);
}
